\section{予想される問題点とその経過}
本節では、incremental な OCaml ステッパを実際に利用するときに発生しうる問題点とその解決方法を挙げ、
大学の授業 ( \ref{section:experiment__course} 節で触れる) で利用してそれらが実際に問題になったかどうかを述べる。

\subsection{文字数の爆発}

\subsubsection{問題点}

本章のステッパでは、
任意のステップの「処理用の出力」に入力プログラムからそこまでの簡約の過程が記されているため、
１ステップ進むごとに文字数が増加する。
具体的には、簡約基 \texttt{e1} が式 \texttt{e2} に簡約されるステップでは、
その時点のコンテキストを \texttt{E}、ステップ番号を \texttt{n} とすると、
簡約前のプログラムが \texttt{E[e1]}、
簡約後のプログラムが \texttt{E[e2[@stepper.reduct n;; e1]]} となる。
\texttt{E} の文字数は変わらないので、\texttt{e2[@stepper.reduct n;;}
と \texttt{]}の分の文字数が増加することになる。
これを続けていくと、１ステップあたり少なくとも22文字は増加することになり、
仮に百万ステップの簡約をするとプログラムは数千万文字になる。
すると、毎ステップの入出力や通信に時間がかかる可能性がある。

\subsubsection{解決方法}

解決策としては、古いステップの attribute は削除してしまうという方法が考えられる。
たくさんのステップを見てから最初の方のステップまで戻るユーザは少ないと仮定すれば、
ある程度前のステップについての attribute があったら、
関数 \texttt{memo} で出力するプログラムを再構成する際に消去すれば、
さほど実際の使用に影響なく出力する文字数を減らすことができる。

\subsubsection{使用した結果}

実際の incremental な OCaml ステッパ (\ref{実装-実際のステッパ} 節) では、
Emacs Lisp プログラムによってステッパ関数の実行や表示を制御する。
これを用いた授業では、文字数の多さが原因の不具合は報告されず、
1 ステップの入出力にかかる時間も利用に支障が出ない程度だった。

\subsection{実行時間}
\label{予想される問題点-実行時間}

\subsubsection{問題点}

ステップ数が膨大になると、後ろの方までステップ実行をするのは困難である。
incremental なステッパ関数での実行速度は通常の OCaml 処理系に決して及ばないので、
１ステップずつ進める場合でも、スキップ機能（\ref{実装-実際のステッパ}節）を使う場合でも、
実行を多く進めるには長い時間が掛かってしまう。

\subsubsection{解決方法}
少しでも急ぐ為には、一般的なデバッガのように、
ステップ実行したい式の付近にユーザがブレークポイントを設定して、
そこからステップ実行を始めるという方法が考えられる。
そのためには、ブレークポイントまでを部分的に native code にコンパイルして実行するなどの方法を取らざるを得ない。
しかしいずれにしても、
通常の OCaml コンパイラを用いても長時間かかるプログラムの実行を早く終わらせることは不可能である。

\subsubsection{使用した結果}

1 ステップずつ進める場合は、プログラムの実行を後ろの方まで進めることは困難であるが、
ステップごとの実行時間が問題になることはなかった。
スキップ機能を使用する場合は、やはり通常の OCaml で実行するよりも長い時間を要した。
具体的には、東京メトロ全線の駅についてダイクストラ法で最短路問題を解くプログラムの実行に、
通常の OCaml では 0.327 秒、incremental な OCaml ステッパではスキップ機能を使用して約 54 秒かかった。

\subsection{関数適用評価スキップ後の前ステップ出力}

\subsubsection{問題点}

関数適用をスキップ（\ref{実装-実際のステッパ}節）した後に前のステップに戻ろうとすると、
スキップで飛ばされたステップには戻ることができない。
たとえば図\ref{figure:skip}のように2の階乗の計算をスキップしたとすると、
図\ref{figure:skip}の右の状態から、incremental でないステッパでは
\begin{itemize}
\item スキップをする前の関数適用式が簡約されるステップ5（図\ref{figure:skip}左）
\item 関数適用式が最終的な値になるステップ17（
\texttt{3 * \colorbox{lightgreen}{(2 * 1)} $\leadsto$ 3 * \colorbox{purple}{2}}）
\end{itemize}
のどちらにも戻ることができたが、incremental なステッパでは前者にしか戻ることができない。

その原因は、incremental でないステッパでは \ref{予想される問題点-実行時間}
節で述べたように文字列検索によってステップ表示を切り替えていたので任意のステップに移ることができたのに対して、
incremental なステッパではステッパ関数が関数適用式が値になるまでを１ステップとして出力し、
その間の簡約についての情報は出力しないからである。

\subsubsection{解決方法}

これを解決するには、
スキップする部分の計算をしている間の簡約についても attribute に情報を蓄え、
スキップ後のステップで全ての簡約の情報が入った長いプログラムを出力する必要がある。
しかしそのようにすると
\ref{予想される問題点-文字数の爆発} 節と
\ref{予想される問題点-実行時間} 節の問題がより深刻になる可能性がある。

\subsubsection{使用した結果}

ステッパを利用した学生に答えてもらったアンケートに
「ステッパの不便なところ、欲しい機能などがあれば教えてください。」
という質問を含めたが、この点に関する要望は出なかった。
