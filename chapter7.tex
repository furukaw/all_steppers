\chapter{結論}
\label{chapter:conclusion}

本研究では、より多くの言語機能への対応と 1 ステップずつの可逆的な実行によって
ステッパをさまざまな言語や環境で使用できる可能性を示し、また
例外処理やモジュールなどの機能に対応したステッパが関数型言語の学習に
及ぼす効果を観察した。

まず、try-with や algebraic effects を例に制御オペレータに対応したステッパを実装した。
ステッパとはプログラムの実行を簡約ステップの列として見せるツールであり、
全ての簡約の前後で、簡約による書き換えの前後のプログラム全体を出力することが求められる。
プログラム全体を出力できるステッパを実装するためには、
コンテキストの情報を保持しながら実行を進めるインタプリタを用意すればよい。
本論文では全体を通して、通常の big-step インタプリタ関数に
コンテキスト情報を保持するための引数を追加し、
簡約の前後で実行中の部分式とそのコンテキスト情報からプログラム全体を再構成して
出力するようにすることでステッパを実装した。

インタプリタ関数にコンテキスト情報を保持する引数を追加する方法は、
\ref{chapter:try-with} 章と \ref{chapter:algebraic effects} 章
で別の方法をとっている。
例外処理の構文 try-with を含む言語に対するステッパを実装する際には、
コンテキストを try 節ごとに区切った 2 層のリスト構造として定義し、
それをインタプリタの再帰の構造に従ってフレームを付け足しながら渡すようにした。
algebraic effects を含む言語のステッパでは、
オペレーション呼び出しによって限定される範囲の継続を引数に持ち
部分的に CPS であるインタプリタを定義し、
そのインタプリタに非関数化、CPS 変換、非関数化という 3 回のプログラム変換を
施すことでメタ継続を1次データとして取得した。
そこからコンテキスト情報を得てステッパを実装した。

次に、incremental なステッパを実装した。
incremental なステッパは、1ステップを簡約したら実行を終えるステッパで、
次のステップの実行を始めるには前回の出力を入力として受け取るという特徴がある。
特に、前のステップに戻るという実行をする際にも前回の出力を入力とするため、
実行を逆向きに進める必要がある。
簡約は基本的に式の情報を失わせる書き換えであり、
簡約後の式から簡約前の式を導出することは不可能である。
そこで簡約後の式にユーザから見えないように簡約前の式の情報を付加することで戻る操作を実現した。

そして、 \ref{chapter:experiment} 章では
ステッパがプログラミング学習に及ぼす効果を調べた。
同じ関数型言語の授業において、ステッパをあまり使わなかった年と
ステッパを多く使った年を比較すると、
ステッパを多く使った年の方が学生が正答するまでにかかる時間が
優位に短かった問題が複数あった。
よって、ステッパが利用できる方が正しいプログラムを早く書けるようになる
可能性があるといえる。

今後の課題として、以下を考えている。

\begin{itemize}
\item algerbraic effects 構文を持つ OCaml である Multicore OCaml の一部の構文に対応したステッパを実装する。
\item incremental なステッパを利用して、クライアントサーバ方式でステッパツール全体を実装する。
\item 他の制御演算子を含む言語のステッパの導出方法を考える。
\end{itemize}

\noindent これらによって、様々なプログラミングの場面でステッパが使えるようになることを期待する。
